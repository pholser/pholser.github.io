---
layout: post
title: "Adamant" Java input streams
published: 1
category:
  - Programming
---
<p>Part of the contract of <code>java.io.InputStream.read(byte[] b, int off, int len)</code> reads:</p><blockquote><p>Reads up to <code>len</code> bytes of data from the input stream into
 an array of bytes. An attempt is made to read as many as
 <code>len</code> bytes, but a smaller number may be read.
 The number of bytes actually read is returned as an integer.</p></blockquote><p>We ran into a situation at work this week where an <code>InputStream</code> we were decorating <em>reaaaally</em> needed to respond with, say, eight bytes if there were at least eight bytes remaining to be read and we requested it to read with a <code>len</code> of eight. However, the <code>read</code> method above is not <em>required</em> to respond with eight bytes when you ask it; it could respond with fewer and still be in compilance.</p>

<p>We decided to introduce the concept of an &quot;adamant&quot; InputStream, which continues to read from its wrapped input stream until it either gets <code>len</code> bytes, or fewer if there really aren't <code>len</code> more bytes to be read--that is, the next call to <code>read</code> answers -1.</p>
<p>Here's the code and test:</p>
<p>&nbsp;</p>

<pre>====begin AdamantInputStream.java====<br />package pholser.io;<br /><br />import java.io.FilterInputStream;<br />import java.io.InputStream;<br />import java.io.IOException;<br /><br />public class AdamantInputStream extends FilterInputStream {<br />&nbsp; &nbsp; public AdamantInputStream( final InputStream in ) {<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; super( in );<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; @Override<br />&nbsp; &nbsp; public int read( final byte[] sink, final int offset, final int length )<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; throws IOException {<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; int totalBytesRead = 0;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; int bytesJustRead;<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; while ( ( bytesJustRead = more( sink, offset, length, totalBytesRead ) ) != -1 ) {<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;totalBytesRead += bytesJustRead;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; }<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; return totalBytesRead;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; private int more( final byte[] sink, final int offset, final int length,<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; final int totalBytesRead ) throws IOException {<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; return super.read( sink, offset + totalBytesRead, length - totalBytesRead );<br />&nbsp; &nbsp; }<br />}<br />====end AdamantInputStream.java====<br /><br />====begin AdamantInputStreamTest.java====<br />package pholser.io;<br /><br />import junit.framework.TestCase;<br />import java.io.ByteArrayInputStream;<br /><br />public class AdamantInputStreamTest extends TestCase {<br />&nbsp; &nbsp; public void testRequestingFewerBytesThanWrappedStreamDelivers() throws Exception {<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; final String source = &quot;abcdefg&quot;;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; final byte[] sink = new byte[ source.length() ];<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; final StingyByteArrayInputStream bytesIn =<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;new StingyByteArrayInputStream( source, 2 );<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; final AdamantInputStream adamantIn = new AdamantInputStream( bytesIn );<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; assertEquals( source.length(), adamantIn.read( sink ) );<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; assertEquals( -1, adamantIn.read() );<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; assertEquals( 5, bytesIn.callsToMultiByteRead );<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; private static final class StingyByteArrayInputStream extends ByteArrayInputStream {<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; int callsToMultiByteRead;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; private int throttle;<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; StingyByteArrayInputStream( final String source, final int throttle ) {<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;super( source.getBytes() );<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;this.throttle = throttle;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; }<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; @Override<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; public synchronized int read( final byte[] sink, final int offset,<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;final int length ) {<br /><br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;final int bytesRead =<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; super.read( sink, offset, Math.min( throttle, length ) );<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;++callsToMultiByteRead;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;return bytesRead;<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; }<br />&nbsp; &nbsp; }<br />}<br />====end AdamantInputStreamTest.java====</pre>

<p>
We interposed this filtering stream between two others which were previously directly linked, and solved our problem.&nbsp; I was really pleased with how the &quot;decorative&quot; aspects of FilterInputStream made the solution nice and clean.
</p>

